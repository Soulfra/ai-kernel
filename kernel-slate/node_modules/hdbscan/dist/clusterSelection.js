"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectClustersUsingLEAF = exports.getClusterTreeLeaves = exports.selectClustersUsingEOM = void 0;
const traversals_1 = require("./traversals");
const epsilonSearch_1 = require("./epsilonSearch");
function selectClustersUsingEOM(clusterTree, stability, nodeList, isCluster, clusterSelectionEpsilon = 0, allowSingleCluster = false, maxClusterSize = 0) {
    const clusterSizes = new Map();
    clusterTree.forEach(t => clusterSizes.set(t.child, t.size));
    for (const node of nodeList) {
        const childSelection = clusterTree
            .filter(c => c.parent === node)
            .map(c => c.child);
        const subtreeStability = childSelection
            .map(cs => stability.get(cs) || 0)
            .reduce((r, n) => r + n, 0);
        if (subtreeStability > (stability.get(node) || 0) || (clusterSizes.get(node) || 0) > maxClusterSize) {
            isCluster.set(node, false);
            stability.set(node, subtreeStability);
        }
        else {
            for (const subNode of (0, traversals_1.bfsFromClusterTree)(clusterTree, node)) {
                if (subNode !== node) {
                    isCluster.set(subNode, false);
                }
            }
        }
    }
    if (clusterSelectionEpsilon !== 0 && clusterTree.length > 0) {
        const eomClusters = new Set();
        for (const [c, cIsCluster] of isCluster) {
            cIsCluster && eomClusters.add(c);
        }
        let selectedClusters = new Set();
        // first check if eomClusters only has root node, which skips epsilon check.
        const root = Math.min(...clusterTree.map(c => c.parent));
        if (eomClusters.size == 1 && [...eomClusters.keys()][0] == root) {
            if (allowSingleCluster) {
                selectedClusters = eomClusters;
            }
        }
        else {
            selectedClusters = (0, epsilonSearch_1.epsilonSearch)(eomClusters, clusterTree, clusterSelectionEpsilon, allowSingleCluster);
        }
        for (const [c] of isCluster) {
            isCluster.set(c, selectedClusters.has(c));
        }
    }
}
exports.selectClustersUsingEOM = selectClustersUsingEOM;
function getClusterTreeLeaves(clusterTree) {
    if (clusterTree.length == 0) {
        return [];
    }
    const root = Math.min(...clusterTree.map(c => c.parent));
    return (0, traversals_1.getLeafDFS)(clusterTree, root);
}
exports.getClusterTreeLeaves = getClusterTreeLeaves;
function selectClustersUsingLEAF(clusterTree, isCluster, clusterSelectionEpsilon = 0, allowSingleCluster = false) {
    const leaves = new Set(getClusterTreeLeaves(clusterTree));
    if (leaves.size == 0) {
        for (const [c] of isCluster) {
            isCluster.set(c, false);
        }
        const minParent = Math.min(...clusterTree.map(t => t.parent));
        isCluster.set(minParent, true);
    }
    let selectedClusters;
    if (clusterSelectionEpsilon !== 0) {
        selectedClusters = (0, epsilonSearch_1.epsilonSearch)(leaves, clusterTree, clusterSelectionEpsilon, allowSingleCluster);
    }
    else {
        selectedClusters = leaves;
    }
    for (const [c] of isCluster) {
        isCluster.set(c, selectedClusters.has(c));
    }
}
exports.selectClustersUsingLEAF = selectClustersUsingLEAF;
