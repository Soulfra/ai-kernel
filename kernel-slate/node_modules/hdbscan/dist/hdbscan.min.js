!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("kd-tree-javascript")):"function"==typeof define&&define.amd?define(["exports","kd-tree-javascript"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).hdbscan={},t.globalThis)}(this,function(t,s){"use strict";function A(e,t){var r=e.length;const n=2*r-r+1;var s=[t];let a=[];for(;s.length;)a=a.concat(s),(s=s.filter(t=>t>=n).map(t=>t-n)).length&&(s=s.map(t=>[e[t].parent,e[t].child]).flat());return a}function g(t,e){var r=[e];let n=[];for(;r.length;)n=n.concat(r),r=t.filter(t=>-1!==r.indexOf(t.parent)).map(t=>t.child);return n}function b(t,e,r,n){const s=new Set,a=new Set;for(const h of t){var i=e.find(t=>t.child===h);if(!i)throw Error("child not found in clusterTree");if(1/i.lambda<r){if(!a.has(h)){var o=function(t,e,r,n){var s=new Array;for(s.push(r);s.length;){const o=s.pop();var a=Math.min(...t.map(t=>t.parent)),i=t.find(t=>t.child===o);if(!i)throw Error("child not found in clusterTree");const h=i.parent;if(h==a)return n?h:o;a=t.find(t=>t.child===h);if(!a)throw Error("parent not found in clusterTree");if(e<1/a.lambda)return h;s.push(h)}return r}(e,r,h,n);s.add(o);for(const l of g(e,o))l!=o&&a.add(l)}}else s.add(h)}return s}function p(t){if(0==t.length)return[];var e=Math.min(...t.map(t=>t.parent));return function(t,e){const r=new Array;var n=new Array;for(n.push(e);n.length;){const a=n.pop();var s=t.filter(t=>t.parent===a).map(t=>t.child);0===s.length?r.push(a):n.push(...s)}return r}(t,e)}class x{constructor(t,e,r,n){this.parent=t,this.child=e,this.lambda=r,this.size=n}}class i{constructor(t){this.data=t}getAncestor(){return this.parent?this.parent.getAncestor():this}}class h{constructor(t){this.parent=new Array(2*(t-1)).fill(-1),this.nextLabel=t,this.size=new Array(t).fill(1).concat(new Array(t-1).fill(0))}union(t,e){this.size[this.nextLabel]=this.size[t]+this.size[e],this.parent[t]=this.nextLabel,this.parent[e]=this.nextLabel,this.size[this.nextLabel]=this.size[t]+this.size[e],this.nextLabel+=1}fastFind(t){for(var e=t;-1!=this.parent[t];)t=this.parent[t];for(;this.parent[e]!=t;)e=this.parent[e],this.parent[e]=t;return t}sizeOf(t){return this.size[t]}}class N{constructor(t){this.data=new Array(t);for(var e=0;e<t;e++)this.data[e]=[e,0];this.isComponent=new Array(t).fill(!0)}union(t,e){t=this.find(t),e=this.find(e);this.data[t][1]<this.data[e][1]?this.data[t][0]=e:this.data[t][1]>this.data[e][1]?this.data[e][0]=t:(this.data[e][0]=t,this.data[t][1]+=1)}recurfind(t){return this.data[t][0]!==t&&(this.data[t][0]=this.recurfind(this.data[t][0]),this.isComponent[t]=!1),this.data[t][0]}find(t){var e=[];let r=t;for(;this.data[r][0]!==r;)e.push(r),r=this.data[r][0];for(var n=r;e.length;){const r=e.pop();this.data[r][0]=n,this.isComponent[r]=!1}return this.data[t][0]}components(){return[...Array(this.isComponent.length).keys()].filter(t=>this.isComponent[t])}}function T(t,e,r=0,n="eom",s=!1,a=0){if(s)throw Error("singleCluster is not supported now.");var i=s?[...e.keys()].sort((t,e)=>e-t):[...e.keys()].sort((t,e)=>e-t).slice(0,e.size-1),o=t.filter(t=>1<t.size);const h=new Map;i.forEach(t=>h.set(t,!0));var l=t.filter(t=>1===t.size).map(t=>t.child),l=Math.max(...l)+1;if(Math.max(...t.map(t=>t.lambda)),a<=0&&(a=l+1),"eom"===n)!function(e,r,n,s,a=0,i=!1,t=0){const o=new Map;e.forEach(t=>o.set(t.child,t.size));for(const d of n){const u=e.filter(t=>t.parent===d).map(t=>t.child);var h=u.map(t=>r.get(t)||0).reduce((t,e)=>t+e,0);if(h>(r.get(d)||0)||(o.get(d)||0)>t)s.set(d,!1),r.set(d,h);else for(const p of g(e,d))p!==d&&s.set(p,!1)}if(0!==a&&0<e.length){const m=new Set;for(var[l,c]of s)c&&m.add(l);let t=new Set;var f,n=Math.min(...e.map(t=>t.parent));1==m.size&&[...m.keys()][0]==n?i&&(t=m):t=b(m,e,a,i);for([f]of s)s.set(f,t.has(f))}}(o,e,i,h,r,s,a);else{if("leaf"!==n)throw Error("Unknown cluster selection method");!function(t,e,r=0,n=!1){var s,a=new Set(p(t));if(0==a.size){for(var[i]of e)e.set(i,!1);var o=Math.min(...t.map(t=>t.parent));e.set(o,!0)}let h;h=0!==r?b(a,t,r,n):a;for([s]of e)e.set(s,h.has(s))}(o,h,r,s)}var c=[...h.entries()].filter(t=>t[1]).map(t=>t[0]).sort();const f=new Map,d=new Map;for(var u=0;u<c.length;u++)f.set(c[u],u),d.set(u,c[u]);return{clusterNodes:c,clusterNodesMap:f,revClusterNodesMap:d,clusterTree:o}}function n(t){return t.sort((t,e)=>t.lambda-e.lambda)}function a(t,e=!1){var r=t;return{sortedMst:r=!e?n(t):r,singleLinkage:function(t){const e=new Array(t.length);for(var r=new h(t.length+1),n=0;n<t.length;++n){var s=t[n].parent,a=t[n].child,i=t[n].lambda,o=r.fastFind(s),s=r.fastFind(a),a=r.sizeOf(o)+r.sizeOf(s);e[n]=new x(o,s,i,a),r.union(o,s)}return e}(r)}}function O(t,e,r,n){var e=function(t,e,r){const n=new s.kdTree(t,r,[]);return t.map(t=>n.nearest(t,e)[0][1])}(t,e,n),t=function(t,e,r,n){var s=t.length;const a=[],i=[],o=new Array(s).fill(1/0);for(var h,l=0,c=1/0,f=1/0,d=1/0,u=1;u<s;u++){a[l]=1;for(var p,m=n[l],f=1/0,c=0,g=0;g<s;g++)a[g]||(h=o[g],d=r(t[l],t[g]),1!=e&&(d/=e),p=n[g],h<m||h<p||h<d?h<f&&(f=h,c=g):(m<p?d<p&&(d=p):d<m&&(d=m),d<h?(o[g]=d)<f&&(f=d,c=g):h<f&&(f=h,c=g)));i[u-1]=new x(l,c,f,0),l=c}return i}(t,r,n,e),{sortedMst:r,singleLinkage:n}=a(t);return{coreDistances:e,mst:t,sortedMst:r,singleLinkage:n}}function j(t,e){for(var r=0,n=0;n<t.length;n++)r+=Math.pow(t[n]-e[n],2);return Math.sqrt(r)}t.DebugInfo=class{constructor(){}},t.Hdbscan=class{constructor({input:t,minClusterSize:e=5,minSamples:r=5,clusterSelectionEpsilon:n=0,clusterSelectionMethod:s="eom",alpha:a=1,metric:i=j,debug:o=!1}){this.input=t,this.minClusterSize=e,this.minSamples=r,this.alpha=a,this.metric=i,this.debug=o;let h;try{var{coreDistances:l,mst:c,sortedMst:f,singleLinkage:d}=O(this.input,this.minSamples,this.alpha,this.metric);this.debug&&(h={coreDistances:l,mst:c,sortedMst:f,singleLinkage:d});var{bfsNodes:u,condensedTree:p}=function(t,e){var r=2*t.length,n=Math.floor(r/2)+1,s=n+1,a=new Array(1+r).fill(0);a[r]=n;var i=[],r=A(t,r);const o=new Array(r.length).fill(!1);for(const u of r)if(!(o[u]||u<n)){var h=t[u-n],l=h.parent,c=h.child,f=0<h.lambda?1/h.lambda:1/0,d=n<=l?t[l-n].size:1,h=n<=c?t[c-n].size:1;if(e<=d&&e<=h)a[l]=s,s+=1,i.push(new x(a[u],a[l],f,d)),a[c]=s,s+=1,i.push(new x(a[u],a[c],f,h));else if(d<e&&h<e){for(const p of A(t,l))p<n&&i.push(new x(a[u],p,f,1)),o[p]=!0;for(const m of A(t,c))m<n&&i.push(new x(a[u],m,f,1)),o[m]=!0}else if(d<e){a[c]=a[u];for(const g of A(t,l))g<n&&i.push(new x(a[u],g,f,1)),o[g]=!0}else{a[l]=a[u];for(const b of A(t,c))b<n&&i.push(new x(a[u],b,f,1)),o[b]=!0}}return{bfsNodes:r,condensedTree:i}}(d,this.minClusterSize);this.debug&&(h=Object.assign(Object.assign({},h),{bfsNodes:u,condensedTree:p}));var m=function(t){var e=Math.max(...t.map(t=>t.child)),r=Math.min(...t.map(t=>t.parent)),n=Math.max(...t.map(t=>t.parent))-r+1;e<r&&(e=r);const s=t.map(t=>[t.child,t.lambda]).sort((t,e)=>t[0]-e[0]),a=new Array(e+1).fill(NaN);for(var i=s.map(t=>t[0]),o=s.map(t=>t[1]),h=t.map(t=>t.parent),l=t.map(t=>t.size),c=t.map(t=>t.lambda),f=-1,d=0,u=0;u<s.length;u++)var p=i[u],m=o[u],d=p==f?Math.min(d,m):(f=(-1!=f&&(a[f]=d),p),m);-1!=f&&(a[f]=d),a[r]=0;const g=new Array(n).fill(0);for(var b=0;b<t.length;b++){var v=h[b],w=c[b],M=l[b];g[v-r]+=(w-a[v])*M}for(var y=new Map,b=0;b<g.length;b++)y.set(r+b,g[b]);return y}(p);this.debug&&(h=Object.assign(Object.assign({},h),{condensedTree:p}));var{clusterNodes:g,clusterNodesMap:b,revClusterNodesMap:v,clusterTree:w}=T(p,m,n,s);this.debug&&(h=Object.assign(Object.assign({},h),{clusterNodes:g,clusterNodesMap:b,revClusterNodesMap:v,clusterTree:w}));var M=function(t,e,r,n=0,s=!1,a=!1){if(s)throw Error("singleCluster is not supported now.");if(a)throw Error("matchReferenceImplementation is not supported now.");var i=t.map(t=>t.parent),o=t.map(t=>t.child),h=Math.min(...i);const l=new Array(h);var c=Math.max(...i);const f=new N(c+1);for(var d=0;d<t.length;d++){var u=o[d],p=i[d];-1===e.indexOf(u)&&f.union(p,u)}for(var m,g,d=0;d<h;d++){const b=f.find(d);b<h?l[d]=-1:b===h?1===e.length&&s?(g=t.find(t=>t.child===d),0!==n?g&&g.lambda>=1/n?l[d]=r.get(b):l[d]=-1:(m=t.filter(t=>t.child===b).map(t=>t.lambda),g&&m&&g.lambda>=Math.max(...m)?l[d]=r.get(b):l[d]=-1)):l[d]=-1:a?(m=(g=t.find(t=>t.child===d))&&g.lambda,g=(g=t.find(t=>t.child===b))&&g.lambda,l[d]=m&&g&&g<m?r.get(b):-1):l[d]=r.get(b)}return l}(p,g,b,n);this.debug&&(h=Object.assign(Object.assign({},h),{labeledInputs:M}));var{clusters:y,noise:z}=function(t){const e=[],r=[];for(var n=0;n<t.length;n++){var s=t[n];-1===s?r.push(n):(e[s]||(e[s]=[]),e[s].push(n))}return{clusters:e,noise:r}}(M);this.debug&&(h=Object.assign(Object.assign({},h),{clusters:y,noise:z}),console.debug("debugInfo: ",h)),this.debugInfo=h,this.clusters=y,this.noise=z}catch(t){throw this.debug&&(console.debug("debugInfo: ",h),console.error("Error: Hdbscan: ",t)),t}}getDebugInfo(){return this.debugInfo}getClusters(){return this.clusters}getNoise(){return this.noise}},t.HierarchyNode=x,t.TreeNode=i,t.euclidean=j,t.mstToBinaryTree=function(t){const s=[...new Array(t.length+1).keys()].map(t=>new i(t));var a=s[0];return n(t).forEach(t=>{const e=s[t.parent].getAncestor(),r=s[t.child].getAncestor(),n=new i(t.lambda);n.left=e,n.right=r,e.parent=r.parent=a=n}),a},Object.defineProperty(t,"__esModule",{value:!0})});
