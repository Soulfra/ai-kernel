import{kdTree}from"kd-tree-javascript";function bfsFromHierarchy(t,e){var r=t.length;const s=2*r-r+1;var n=[e];let a=[];for(;n.length;)a=a.concat(n),(n=n.filter(e=>e>=s).map(e=>e-s)).length&&(n=n.map(e=>[t[e].parent,t[e].child]).flat());return a}function bfsFromClusterTree(e,t){var r=[t];let s=[];for(;r.length;)s=s.concat(r),r=e.filter(e=>-1!==r.indexOf(e.parent)).map(e=>e.child);return s}function getLeafDFS(e,t){const r=new Array;var s=new Array;for(s.push(t);s.length;){const a=s.pop();var n=e.filter(e=>e.parent===a).map(e=>e.child);0===n.length?r.push(a):s.push(...n)}return r}function traverseUpwards(e,t,r,s){var n=new Array;for(n.push(r);n.length;){const o=n.pop();var a=Math.min(...e.map(e=>e.parent)),i=e.find(e=>e.child===o);if(!i)throw Error("child not found in clusterTree");const l=i.parent;if(l==a)return s?l:o;a=e.find(e=>e.child===l);if(!a)throw Error("parent not found in clusterTree");if(t<1/a.lambda)return l;n.push(l)}return r}function epsilonSearch(e,t,r,s){const n=new Set,a=new Set;for(const l of e){var i=t.find(e=>e.child===l);if(!i)throw Error("child not found in clusterTree");if(1/i.lambda<r){if(!a.has(l)){var o=traverseUpwards(t,r,l,s);n.add(o);for(const c of bfsFromClusterTree(t,o))c!=o&&a.add(c)}}else n.add(l)}return n}function selectClustersUsingEOM(t,r,s,n,a=0,i=!1,e=0){const o=new Map;t.forEach(e=>o.set(e.child,e.size));for(const u of s){const f=t.filter(e=>e.parent===u).map(e=>e.child);var l=f.map(e=>r.get(e)||0).reduce((e,t)=>e+t,0);if(l>(r.get(u)||0)||(o.get(u)||0)>e)n.set(u,!1),r.set(u,l);else for(const p of bfsFromClusterTree(t,u))p!==u&&n.set(p,!1)}if(0!==a&&0<t.length){const m=new Set;for(var[c,h]of n)h&&m.add(c);let e=new Set;var d,s=Math.min(...t.map(e=>e.parent));1==m.size&&[...m.keys()][0]==s?i&&(e=m):e=epsilonSearch(m,t,a,i);for([d]of n)n.set(d,e.has(d))}}function getClusterTreeLeaves(e){if(0==e.length)return[];var t=Math.min(...e.map(e=>e.parent));return getLeafDFS(e,t)}function selectClustersUsingLEAF(e,t,r=0,s=!1){var n,a=new Set(getClusterTreeLeaves(e));if(0==a.size){for(var[i]of t)t.set(i,!1);var o=Math.min(...e.map(e=>e.parent));t.set(o,!0)}let l;l=0!==r?epsilonSearch(a,e,r,s):a;for([n]of t)t.set(n,l.has(n))}class HierarchyNode{constructor(e,t,r,s){this.parent=e,this.child=t,this.lambda=r,this.size=s}}class DebugInfo{constructor(){}}class TreeNode{constructor(e){this.data=e}getAncestor(){return this.parent?this.parent.getAncestor():this}}class UnionFind{constructor(e){this.parent=new Array(2*(e-1)).fill(-1),this.nextLabel=e,this.size=new Array(e).fill(1).concat(new Array(e-1).fill(0))}union(e,t){this.size[this.nextLabel]=this.size[e]+this.size[t],this.parent[e]=this.nextLabel,this.parent[t]=this.nextLabel,this.size[this.nextLabel]=this.size[e]+this.size[t],this.nextLabel+=1}fastFind(e){for(var t=e;-1!=this.parent[e];)e=this.parent[e];for(;this.parent[t]!=e;)t=this.parent[t],this.parent[t]=e;return e}sizeOf(e){return this.size[e]}}class TreeUnionFind{constructor(e){this.data=new Array(e);for(var t=0;t<e;t++)this.data[t]=[t,0];this.isComponent=new Array(e).fill(!0)}union(e,t){e=this.find(e),t=this.find(t);this.data[e][1]<this.data[t][1]?this.data[e][0]=t:this.data[e][1]>this.data[t][1]?this.data[t][0]=e:(this.data[t][0]=e,this.data[e][1]+=1)}recurfind(e){return this.data[e][0]!==e&&(this.data[e][0]=this.recurfind(this.data[e][0]),this.isComponent[e]=!1),this.data[e][0]}find(e){var t=[];let r=e;for(;this.data[r][0]!==r;)t.push(r),r=this.data[r][0];for(var s=r;t.length;){const r=t.pop();this.data[r][0]=s,this.isComponent[r]=!1}return this.data[e][0]}components(){return[...Array(this.isComponent.length).keys()].filter(e=>this.isComponent[e])}}function condenseTree(e,t){var r=2*e.length,s=Math.floor(r/2)+1,n=s+1,a=new Array(1+r).fill(0);a[r]=s;var i=[],r=bfsFromHierarchy(e,r);const o=new Array(r.length).fill(!1);for(const f of r)if(!(o[f]||f<s)){var l=e[f-s],c=l.parent,h=l.child,d=0<l.lambda?1/l.lambda:1/0,u=s<=c?e[c-s].size:1,l=s<=h?e[h-s].size:1;if(t<=u&&t<=l)a[c]=n,n+=1,i.push(new HierarchyNode(a[f],a[c],d,u)),a[h]=n,n+=1,i.push(new HierarchyNode(a[f],a[h],d,l));else if(u<t&&l<t){for(const p of bfsFromHierarchy(e,c))p<s&&i.push(new HierarchyNode(a[f],p,d,1)),o[p]=!0;for(const m of bfsFromHierarchy(e,h))m<s&&i.push(new HierarchyNode(a[f],m,d,1)),o[m]=!0}else if(u<t){a[h]=a[f];for(const g of bfsFromHierarchy(e,c))g<s&&i.push(new HierarchyNode(a[f],g,d,1)),o[g]=!0}else{a[c]=a[f];for(const b of bfsFromHierarchy(e,h))b<s&&i.push(new HierarchyNode(a[f],b,d,1)),o[b]=!0}}return{bfsNodes:r,condensedTree:i}}function computeStabilities(e){var t=Math.max(...e.map(e=>e.child)),r=Math.min(...e.map(e=>e.parent)),s=Math.max(...e.map(e=>e.parent))-r+1;t<r&&(t=r);const n=e.map(e=>[e.child,e.lambda]).sort((e,t)=>e[0]-t[0]),a=new Array(t+1).fill(NaN);for(var i=n.map(e=>e[0]),o=n.map(e=>e[1]),l=e.map(e=>e.parent),c=e.map(e=>e.size),h=e.map(e=>e.lambda),d=-1,u=0,f=0;f<n.length;f++)var p=i[f],m=o[f],u=p==d?Math.min(u,m):(d=(-1!=d&&(a[d]=u),p),m);-1!=d&&(a[d]=u),a[r]=0;const g=new Array(s).fill(0);for(var b=0;b<e.length;b++){var v=l[b],w=h[b],y=c[b];g[v-r]+=(w-a[v])*y}for(var M=new Map,b=0;b<g.length;b++)M.set(r+b,g[b]);return M}function getClusterNodes(e,t,r=0,s="eom",n=!1,a=0){if(n)throw Error("singleCluster is not supported now.");var i=n?[...t.keys()].sort((e,t)=>t-e):[...t.keys()].sort((e,t)=>t-e).slice(0,t.size-1),o=e.filter(e=>1<e.size);const l=new Map;i.forEach(e=>l.set(e,!0));var c=e.filter(e=>1===e.size).map(e=>e.child),c=Math.max(...c)+1;if(Math.max(...e.map(e=>e.lambda)),a<=0&&(a=c+1),"eom"===s)selectClustersUsingEOM(o,t,i,l,r,n,a);else{if("leaf"!==s)throw Error("Unknown cluster selection method");selectClustersUsingLEAF(o,l,r,n)}var h=[...l.entries()].filter(e=>e[1]).map(e=>e[0]).sort();const d=new Map,u=new Map;for(var f=0;f<h.length;f++)d.set(h[f],f),u.set(f,h[f]);return{clusterNodes:h,clusterNodesMap:d,revClusterNodesMap:u,clusterTree:o}}function labelClusters(e,t,r,s=0,n=!1,a=!1){if(n)throw Error("singleCluster is not supported now.");if(a)throw Error("matchReferenceImplementation is not supported now.");var i=e.map(e=>e.parent),o=e.map(e=>e.child),l=Math.min(...i);const c=new Array(l);var h=Math.max(...i);const d=new TreeUnionFind(h+1);for(var u=0;u<e.length;u++){var f=o[u],p=i[u];-1===t.indexOf(f)&&d.union(p,f)}for(var m,g,u=0;u<l;u++){const b=d.find(u);b<l?c[u]=-1:b===l?1===t.length&&n?(g=e.find(e=>e.child===u),0!==s?g&&g.lambda>=1/s?c[u]=r.get(b):c[u]=-1:(m=e.filter(e=>e.child===b).map(e=>e.lambda),g&&m&&g.lambda>=Math.max(...m)?c[u]=r.get(b):c[u]=-1)):c[u]=-1:a?(m=(g=e.find(e=>e.child===u))&&g.lambda,g=(g=e.find(e=>e.child===b))&&g.lambda,c[u]=m&&g&&g<m?r.get(b):-1):c[u]=r.get(b)}return c}function getClustersAndNoise(e){const t=[],r=[];for(var s=0;s<e.length;s++){var n=e[s];-1===n?r.push(s):(t[n]||(t[n]=[]),t[n].push(s))}return{clusters:t,noise:r}}function kdTreeCoreDistance(e,t,r){const s=new kdTree(e,r,[]);return e.map(e=>s.nearest(e,t)[0][1])}function buildMstUsingPrim(e,t,r,s){var n=e.length;const a=[],i=[],o=new Array(n).fill(1/0);for(var l,c=0,h=1/0,d=1/0,u=1/0,f=1;f<n;f++){a[c]=1;for(var p,m=s[c],d=1/0,h=0,g=0;g<n;g++)a[g]||(l=o[g],u=r(e[c],e[g]),1!=t&&(u/=t),p=s[g],l<m||l<p||l<u?l<d&&(d=l,h=g):(m<p?u<p&&(u=p):u<m&&(u=m),u<l?(o[g]=u)<d&&(d=u,h=g):l<d&&(d=l,h=g)));i[f-1]=new HierarchyNode(c,h,d,0),c=h}return i}function sortMst(e){return e.sort((e,t)=>e.lambda-t.lambda)}function mstToBinaryTree(e){const n=[...new Array(e.length+1).keys()].map(e=>new TreeNode(e));var a=n[0];return sortMst(e).forEach(e=>{const t=n[e.parent].getAncestor(),r=n[e.child].getAncestor(),s=new TreeNode(e.lambda);s.left=t,s.right=r,t.parent=r.parent=a=s}),a}function createSingleLinkage(e){const t=new Array(e.length);for(var r=new UnionFind(e.length+1),s=0;s<e.length;++s){var n=e[s].parent,a=e[s].child,i=e[s].lambda,o=r.fastFind(n),n=r.fastFind(a),a=r.sizeOf(o)+r.sizeOf(n);t[s]=new HierarchyNode(o,n,i,a),r.union(o,n)}return t}function buildSingleLinkage(e,t=!1){var r=e;return{sortedMst:r=!t?sortMst(e):r,singleLinkage:createSingleLinkage(r)}}function kdTreePrim(e,t,r,s){var t=kdTreeCoreDistance(e,t,s),e=buildMstUsingPrim(e,r,s,t),{sortedMst:r,singleLinkage:s}=buildSingleLinkage(e);return{coreDistances:t,mst:e,sortedMst:r,singleLinkage:s}}function euclidean(e,t){for(var r=0,s=0;s<e.length;s++)r+=Math.pow(e[s]-t[s],2);return Math.sqrt(r)}class Hdbscan{constructor({input:e,minClusterSize:t=5,minSamples:r=5,clusterSelectionEpsilon:s=0,clusterSelectionMethod:n="eom",alpha:a=1,metric:i=euclidean,debug:o=!1}){this.input=e,this.minClusterSize=t,this.minSamples=r,this.alpha=a,this.metric=i,this.debug=o;let l;try{var{coreDistances:c,mst:h,sortedMst:d,singleLinkage:u}=kdTreePrim(this.input,this.minSamples,this.alpha,this.metric);this.debug&&(l={coreDistances:c,mst:h,sortedMst:d,singleLinkage:u});var{bfsNodes:f,condensedTree:p}=condenseTree(u,this.minClusterSize);this.debug&&(l=Object.assign(Object.assign({},l),{bfsNodes:f,condensedTree:p}));var m=computeStabilities(p);this.debug&&(l=Object.assign(Object.assign({},l),{condensedTree:p}));var{clusterNodes:g,clusterNodesMap:b,revClusterNodesMap:v,clusterTree:w}=getClusterNodes(p,m,s,n);this.debug&&(l=Object.assign(Object.assign({},l),{clusterNodes:g,clusterNodesMap:b,revClusterNodesMap:v,clusterTree:w}));var y=labelClusters(p,g,b,s);this.debug&&(l=Object.assign(Object.assign({},l),{labeledInputs:y}));var{clusters:M,noise:N}=getClustersAndNoise(y);this.debug&&(l=Object.assign(Object.assign({},l),{clusters:M,noise:N}),console.debug("debugInfo: ",l)),this.debugInfo=l,this.clusters=M,this.noise=N}catch(e){throw this.debug&&(console.debug("debugInfo: ",l),console.error("Error: Hdbscan: ",e)),e}}getDebugInfo(){return this.debugInfo}getClusters(){return this.clusters}getNoise(){return this.noise}}export{DebugInfo,Hdbscan,HierarchyNode,TreeNode,euclidean,mstToBinaryTree};
