"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseUpwards = exports.getLeafDFS = exports.recurseLeafDFS = exports.bfsFromClusterTree = exports.bfsFromHierarchy = void 0;
function bfsFromHierarchy(hierarchy, root) {
    const dim = hierarchy.length;
    const maxNode = 2 * dim;
    const numPoints = maxNode - dim + 1;
    var toProcess = [root];
    let result = [];
    while (toProcess.length) {
        result = result.concat(toProcess);
        toProcess = toProcess
            .filter(x => x >= numPoints)
            .map(x => x - numPoints);
        if (toProcess.length) {
            toProcess = toProcess.map(t => [hierarchy[t].parent, hierarchy[t].child]).flat();
        }
    }
    return result;
}
exports.bfsFromHierarchy = bfsFromHierarchy;
function bfsFromClusterTree(tree, bfsRoot) {
    var toProcess = [bfsRoot];
    let result = [];
    while (toProcess.length) {
        result = result.concat(toProcess);
        toProcess = tree
            .filter(t => toProcess.indexOf(t.parent) !== -1)
            .map(t => t.child);
    }
    return result;
}
exports.bfsFromClusterTree = bfsFromClusterTree;
function recurseLeafDFS(clusterTree, currentNode) {
    const children = clusterTree
        .filter(c => c.parent === currentNode)
        .map(c => c.child);
    if (children.length === 0) {
        return [currentNode];
    }
    else {
        const result = new Array();
        for (const child of children) {
            result.push(...recurseLeafDFS(clusterTree, child));
        }
        return result;
    }
}
exports.recurseLeafDFS = recurseLeafDFS;
function getLeafDFS(clusterTree, node) {
    const result = new Array();
    var stack = new Array();
    stack.push(node);
    while (stack.length) {
        const currentNode = stack.pop();
        const children = clusterTree
            .filter(c => c.parent === currentNode)
            .map(c => c.child);
        if (children.length === 0) {
            result.push(currentNode);
        }
        else {
            stack.push(...children);
        }
    }
    return result;
}
exports.getLeafDFS = getLeafDFS;
function traverseUpwards(clusterTree, clusterSelectionEpsilon, leaf, allowSingleCluster) {
    var stack = new Array();
    stack.push(leaf);
    while (stack.length) {
        const currentLeaf = stack.pop();
        const root = Math.min(...clusterTree.map(c => c.parent));
        const childMatch = clusterTree.find(t => t.child === currentLeaf);
        if (!childMatch) {
            throw Error('child not found in clusterTree');
        }
        const parent = childMatch.parent;
        if (parent == root) {
            if (allowSingleCluster) {
                return parent;
            }
            else {
                return currentLeaf;
            }
        }
        const parentMatch = clusterTree.find(t => t.child === parent);
        if (!parentMatch) {
            throw Error('parent not found in clusterTree');
        }
        const parentEps = 1 / parentMatch.lambda;
        if (parentEps > clusterSelectionEpsilon) {
            return parent;
        }
        else {
            stack.push(parent);
        }
    }
    return leaf;
}
exports.traverseUpwards = traverseUpwards;
